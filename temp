// @NUL0x4C | @mrd0x : MalDevAcademy

#include <Windows.h>
#include <intrin.h>
#include <stdio.h>

// the new data stream name
#define NEW_STREAM L":Maldev"


BOOL DeleteSelfFromDiskW10() {


	WCHAR					szPath [MAX_PATH * 2]	= { 0 };
	FILE_DISPOSITION_INFO	Delete					= { 0 };
	HANDLE					hFile					= INVALID_HANDLE_VALUE;
	PFILE_RENAME_INFO		pRename					= NULL;
	const wchar_t*			NewStream				= (const wchar_t*)NEW_STREAM;
	SIZE_T					StreamLength			= wcslen(NewStream) * sizeof(wchar_t);
	SIZE_T					sRename					= sizeof(FILE_RENAME_INFO) + StreamLength;

	// allocating enough buffer for the 'FILE_RENAME_INFO' structure
	pRename = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sRename);
	if (!pRename) {
		printf("[!] HeapAlloc Failed With Error : %d \n", GetLastError());
		return FALSE;
	}

	// cleaning up the structures
	ZeroMemory(szPath, sizeof(szPath));
	ZeroMemory(&Delete, sizeof(FILE_DISPOSITION_INFO));

	//--------------------------------------------------------------------------------------------------------------------------
	// marking the file for deletion (used in the 2nd SetFileInformationByHandle call) 
	Delete.DeleteFile = TRUE;

	// setting the new data stream name buffer and size in the 'FILE_RENAME_INFO' structure
	pRename->FileNameLength = StreamLength;
	RtlCopyMemory(pRename->FileName, NewStream, StreamLength);

	//--------------------------------------------------------------------------------------------------------------------------

	// used to get the current file name
	if (GetModuleFileNameW(NULL, szPath, MAX_PATH * 2) == 0) {
		printf("[!] GetModuleFileNameW Failed With Error : %d \n", GetLastError());
		return FALSE;
	}

	//--------------------------------------------------------------------------------------------------------------------------
	// RENAMING

	// openning a handle to the current file
	hFile = CreateFileW(szPath, DELETE | SYNCHRONIZE, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		printf("[!] CreateFileW [R] Failed With Error : %d \n", GetLastError());
		return FALSE;
	}

	wprintf(L"[i] Renaming :$DATA to %s  ...", NEW_STREAM);

	// renaming the data stream
	if (!SetFileInformationByHandle(hFile, FileRenameInfo, pRename, sRename)) {
		printf("[!] SetFileInformationByHandle [R] Failed With Error : %d \n", GetLastError());
		return FALSE;
	}
	wprintf(L"[+] DONE \n");

	CloseHandle(hFile);

	//--------------------------------------------------------------------------------------------------------------------------
	// DELEING

	// openning a new handle to the current file
	hFile = CreateFileW(szPath, DELETE | SYNCHRONIZE, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
	if (hFile == INVALID_HANDLE_VALUE && GetLastError() == ERROR_FILE_NOT_FOUND) {
		// in case the file is already deleted
		return TRUE;
	}
	if (hFile == INVALID_HANDLE_VALUE) {
		printf("[!] CreateFileW [D] Failed With Error : %d \n", GetLastError());
		return FALSE;
	}

	wprintf(L"[i] DELETING ...");

	// marking for deletion after the file's handle is closed
	if (!SetFileInformationByHandle(hFile, FileDispositionInfo, &Delete, sizeof(Delete))) {
		printf("[!] SetFileInformationByHandle [D] Failed With Error : %d \n", GetLastError());
		return FALSE;
	}
	wprintf(L"[+] DONE \n");

	CloseHandle(hFile);

	//--------------------------------------------------------------------------------------------------------------------------

	// freeing the allocated buffer
	HeapFree(GetProcessHeap(), 0, pRename);

	return TRUE;
}


// ==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==
// ==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==
// Patched on 9/18/2025 by @NUL0x4C | @mrd0x : MalDevAcademy
// W11 Support

typedef struct _FILE_RENAME_INFO2 {
#if (_WIN32_WINNT >= _WIN32_WINNT_WIN10_RS1)
    union {
        BOOLEAN ReplaceIfExists;
        DWORD Flags;
    } DUMMYUNIONNAME;
#else
    BOOLEAN ReplaceIfExists;
#endif
    HANDLE RootDirectory;
    DWORD FileNameLength;
    WCHAR FileName[MAX_PATH];     // Instead of FileName[1]
} FILE_RENAME_INFO2, * PFILE_RENAME_INFO2;


#ifndef RAND_MAX
#define RAND_MAX 0x7FFF
#endif // !RAND_MAX


// @ Substitute for rand()
// @ Requires 'intrin.h'

static unsigned int rdrand32() {

    UINT32 uRandomValue = 0x00;

    if (_rdrand32_step(&uRandomValue))
    {
       return (int)(uRandomValue % (RAND_MAX + 1u));
    }

    return 0x00;
}


BOOL DeleteSelfFromDiskW11() {

    WCHAR                       szNewStream[7]              = L":%x%x\x00";
    BOOL                        bSTATE                      = FALSE;
    WCHAR					    szFileName[MAX_PATH * 2]    = { 0x00 };
    FILE_RENAME_INFO2           FileRenameInfo_2            = { .FileNameLength = sizeof(szNewStream), .ReplaceIfExists = FALSE, .RootDirectory = 0x00 };
    FILE_DISPOSITION_INFO_EX    FileDisposalInfoEx          = { 0 };
    HANDLE                      hLocalImgFileHandle         = INVALID_HANDLE_VALUE;

    if (GetModuleFileNameW(NULL, szFileName, (MAX_PATH * 2)) == 0x00) {
        printf("[!] GetModuleFileNameW Failed With Error: %d \n", GetLastError());
        goto _END_OF_FUNC;
    }

    swprintf(FileRenameInfo_2.FileName, MAX_PATH, szNewStream, rdrand32(), rdrand32());

    if ((hLocalImgFileHandle = CreateFileW(szFileName, DELETE | SYNCHRONIZE, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, NULL, NULL)) == INVALID_HANDLE_VALUE) {
        printf("[!] CreateFileW [%d] Failed With Error: %d \n", __LINE__, GetLastError());
        goto _END_OF_FUNC;
    }

    if (!SetFileInformationByHandle(hLocalImgFileHandle, FileRenameInfo, &FileRenameInfo_2, sizeof(FILE_RENAME_INFO2))) {
        printf("[!] SetFileInformationByHandle [%d] Failed With Error: %d \n", __LINE__, GetLastError());
        goto _END_OF_FUNC;
    }

    CloseHandle(hLocalImgFileHandle);

    if ((hLocalImgFileHandle = CreateFileW(szFileName, DELETE | SYNCHRONIZE, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, NULL, NULL)) == INVALID_HANDLE_VALUE) {
        printf("[!] CreateFileW [%d] Failed With Error: %d \n", __LINE__, GetLastError());
        goto _END_OF_FUNC;
    }

    FileDisposalInfoEx.Flags = FILE_DISPOSITION_FLAG_DELETE | FILE_DISPOSITION_FLAG_POSIX_SEMANTICS;

    if (!SetFileInformationByHandle(hLocalImgFileHandle, FileDispositionInfoEx, &FileDisposalInfoEx, sizeof(FILE_DISPOSITION_INFO_EX))) {
        printf("[!] SetFileInformationByHandle [%d] Failed With Error: %d \n", __LINE__, GetLastError());
        goto _END_OF_FUNC;
    }

    bSTATE = TRUE;

_END_OF_FUNC:
    if (hLocalImgFileHandle != INVALID_HANDLE_VALUE)
        CloseHandle(hLocalImgFileHandle);
    return bSTATE;
}

// ==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==
// ==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==



int main(int argc, char* argv[]) {

	if (!DeleteSelfFromDiskW11()) {
		return -1;
	}

	printf("[+] %s Should Be Deleted \n", argv[0]);

	printf("[#] Press <Enter> To Quit ... ");
	getchar();

	return 0;

}
